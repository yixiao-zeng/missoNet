#' Quickly generate simulated data
#'
#' This function 
#'
#' @param X (Optional) an user-supplied predictor matrix (\eqn{n\times p}{n x p}). If not `\code{NULL}` then `\code{Sigma.X}` will be ignored.
#' @param Beta (Optional) an user-supplied matrix (\eqn{p\times q}{p x q}) for the coefficients. If not `\code{NULL}` then `\code{Beta.row.sparsity}` and `\code{Beta.elem.sparsity}` will be ignored.
#' @param E (Optional) an user-supplied error matrix (\eqn{n\times q}{n x q}). If not `\code{NULL}` then `\code{Theta}` will be ignored. A clean response matrix will be generated by `\code{Y = X \%*\% Beta + E}`.
#' @param Theta (Optional) an user-supplied positive definite matrix (\eqn{q\times q}{q x q}) for the inverse covariance. Default is `\code{Theta = NULL}` and the program will generate a block-structured matrix having four blocks corresponding to four types of network structures: independent, weak graph, strong graph and chain. Only needed when `\code{E = NULL}`. 
#' @param n Sample size. 
#' @param p The dimensionality of predictors.
#' @param q The dimensionality of responses.
#' @param rho A scalar or a numeric vector of length \eqn{q}{q} specifying the approximate proportion of missing values in each column of `\code{Z}`.
#' @param missing.type String: can be `\code{"MCAR"}` (default), `\code{"MAR"}` or `\code{"MNAR"}`.
#' @param Sigma.X An user-supplied positive definite covariance matrix (\eqn{p\times p}{p x p}) for generating a multivariate Gaussian distributed `\code{X}`. If `\code{Sigma.X = NULL}` (default), the program uses an AR(1) covariance with 0.7 autocorrelation. Only needed when `\code{X = NULL}`. 
#' @param Beta.row.sparsity A Bernoulli parameter between 0 and 1 controlling the approximate proportion of non-zero rows in `\code{Beta}`. Only needed when `\code{Beta = NULL}`.
#' @param Beta.elem.sparsity A Bernoulli parameter between 0 and 1 controlling the approximate proportion of non-zero elements in those non-zero rows (i.e., rows that are not all zeros). Only needed when `\code{Beta = NULL}`.
#' @param with.seed An user-supplied random seed for generation.
#' 
#' @return This function returns a `\code{list}` of simulated data and parameters including:
#' \item{\code{X}}{A predictor matrix (\eqn{n\times p}{n x p}).}
#' \item{\code{Y}}{A clean response matrix (\eqn{n\times q}{n x q}).}
#' \item{\code{Z}}{A corrupted response matrix with missing data coded as `\code{NA}`s (\eqn{n\times q}{n x q}).}
#' \item{\code{Beta}}{A true coefficient matrix (\eqn{p\times q}{p x q}).}
#' \item{\code{Theta}}{A true precision matrix (\eqn{q\times q}{q x q}).}
#' \item{\code{rho}}{A vector of length \eqn{q}{q} storing the missing probability.}
#' \item{\code{missing.type}}{The type of missing mechanism.}
#' @export
#'
#' @examples
#' # overall missing probability 0.1, equivalent to 'rho = rep(0.1, q)'
#' dat <- generateData(n = 300, p = 50, q = 20, rho = 0.1, missing.type = "MCAR")
#' 
#' # specify the missing probability for each response variable individually
#' rho <- runif(n = 20, min = 0, max = 0.2)
#' dat <- generateData(n = 300, p = 50, q = 20, rho = rho, missing.type = "MAR")
#' 
#' # user-supplied true 'Beta' and 'Theta'
#' n <- 300
#' p <- 50
#' q <- 20
#' Beta <- matrix(rnorm(p * q), p, q)
#' Theta <- diag(q)  # a diagonal precision matrix just for illustration
#' dat <- generateData(Beta = Beta, Theta = Theta, n = n, p = p, q = q, rho = 0.1,
#'                     Beta.row.sparsity = 0.2, Beta.elem.sparsity = 0.3,
#'                     missing.type = "MNAR")

generateData <- function(X = NULL, Beta = NULL, E = NULL, Theta = NULL,
                         n, p, q, rho, missing.type = "MCAR",
                         Sigma.X = NULL, Beta.row.sparsity = 0.2, Beta.elem.sparsity = 0.2,
                         with.seed = NULL) {
  set.seed(with.seed)
  
  if (is.null(X)) {
    X <- genX(n = n, p = p, Sigma.X = Sigma.X)
  }
  
  if (is.null(Beta)) {
    p <- ncol(X)
    Beta <- genBeta(p = p, q = q, s1 = Beta.elem.sparsity, s2 = Beta.row.sparsity)
  }
  
  if (is.null(E)) {
    q <- ncol(Beta)
    if (is.null(Theta)) {
      Theta <- genTheta(q)
    }
    Y <- genY(X = X, BETAstar = Beta, Theta)
  } else {
    Y <- X %*% Beta + E
  }
  
  if (length(rho) == 1) {
    rho <- rep(rho, q)
  }
  if (length(rho) != q) {
    stop("\n`rho` must be a scalar or a q-dimensional vector.\n")
  }
  
  Z <- genZ(X = X, BETAstar = Beta, Y = Y, rho = rho, type = missing.type)
  
  return(list(X = X, Y = Y, Z = Z, Beta = Beta, Theta = Theta, rho = rho, missing.type = missing.type))
}