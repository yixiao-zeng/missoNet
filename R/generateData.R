#' Generate simulation data from parameters
#'
#' @param X (Optional) a user supplied numeric predictor matrix (n by p). If not \code{NULL} then \code{Sigma.X} will be ignored.
#' @param Beta (Optional) a user supplied numeric coefficient matrix (p by q). If not \code{NULL} then \code{Beta.elem.sparsity} and \code{Beta.row.sparsity} will be ignored.
#' @param E (Optional) a user supplied numeric error matrix (n by q). If not \code{NULL} then \code{Theta} will be ignored. The final response matrix is generated by \code{Y = X \%*\% Beta + E}.
#' @param Theta (Optional) a user supplied inverse covariance matrix (q by q) for error. Default is \code{Theta = NULL} and the program will generate a block matrix having four blocks corresponding to four types of network structures: independent, weak graph, strong graph and chain. Only needed when \code{E = NULL}. 
#' @param n Sample size. 
#' @param p The dimensionality of predictors.
#' @param q The dimensionality of responses.
#' @param rho A scalar or a numeric vector of length q: a user supplied missing probability for response variables.
#' @param missing.type Character string: can be \code{"MCAR"}, \code{"MAR"} or \code{"MNAR"}; default is \code{missing.type = "MCAR"}. 
#' @param Sigma.X A user supplied PD covariance matrix for generating multivariate normal distributed X. If \code{NULL}, use AR(1) covariance with 0.7 autocorrelation by default. Only needed when \code{X = NULL}. 
#' @param Beta.elem.sparsity A value between 0 and 1 controlling the approximate proportion of non-zero elements in Beta. Only needed when \code{Beta = NULL}. 
#' @param Beta.row.sparsity A value between 0 and 1 controlling the approximate proportion of non-zero rows in Beta. Only needed when \code{Beta = NULL}. 
#' @param with.seed Random seed. 
#' 
#' @return This function returns a \code{list} containing:
#' \itemize{
#' \item \code{X}: predictor matrix (n by p).
#' \item \code{Y}: response matrix without missing data (n by q).
#' \item \code{Z}: response matrix with missing data (n by q).
#' \item \code{Beta}: coefficient matrix (p by q).
#' \item \code{Theta}: inverse covariance matrix (q by q)
#' \item \code{rho}: a vector of length q: working missing probability.
#' \item \code{missing.type}: type of missing data.
#' }
#' @export
#'
#' @examples generateData(n = 300, p = 50, q = 20, rho = 0.1, missing.type = "MCAR")

generateData <- function(X = NULL, Beta = NULL, E = NULL, Theta = NULL,
                         n, p, q, rho, missing.type = "MCAR",
                         Sigma.X = NULL, Beta.elem.sparsity = 0.2, Beta.row.sparsity = 0.2,
                         with.seed = NULL) {
  set.seed(with.seed)
  
  if (is.null(X)) {
    X <- genX(n = n, p = p, Sigma.X = Sigma.X)
  }
  
  if (is.null(Beta)) {
    p <- ncol(X)
    Beta <- genBeta(p = p, q = q, s1 = Beta.elem.sparsity, s2 = Beta.row.sparsity)
  }
  
  if (is.null(E)) {
    q <- ncol(Beta)
    if (is.null(Theta)) {
      Theta <- genTheta(q)
    }
    Y <- genY(X = X, BETAstar = Beta, Theta)
  } else {
    Y <- X %*% Beta + E
  }
  
  if (length(rho) == 1) {
    rho <- rep(rho, q)
  }
  if (length(rho) != q) {
    stop("rho must be a scalar or a q-dimensional vector.\n")
  }
  
  Z <- genZ(X = X, BETAstar = Beta, Y = Y, rho = rho, type = missing.type)
  
  return(list(X = X, Y = Y, Z = Z, Beta = Beta, Theta = Theta, rho = rho, missing.type = missing.type))
}